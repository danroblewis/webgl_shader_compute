<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Layer 1: Custom WebGL Rendering</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
        }
        .badge {
            display: inline-block;
            background: #9c27b0;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        canvas {
            border: 1px solid #ddd;
            display: block;
            margin: 20px auto;
        }
        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
        }
        code {
            font-family: 'Consolas', 'Monaco', monospace;
        }
    </style>
</head>
<body>
    <h1>
        Layer 1: Custom WebGL Rendering
        <span class="badge">ADVANCED</span>
    </h1>
    
    <div class="container">
        <p>
            This example demonstrates <strong>Layer 1 API</strong>: accessing raw WebGL resources for custom rendering.
            We get the simulation texture and render it with a custom shader that applies a "heat map" effect.
        </p>
    </div>

    <canvas id="canvas" width="512" height="512"></canvas>

    <div class="container">
        <h2>Layer 1 API Demo</h2>
        <pre><code>// Get raw WebGL resources
const gl = sim.getContext();
const texture = sim.getTexture();

// Create custom rendering pipeline
const renderProgram = createCustomShader(gl);

// Render simulation texture with custom effects
gl.useProgram(renderProgram);
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);</code></pre>

        <p>
            ✅ <strong>Pros:</strong> Maximum control, custom effects, GPU-to-GPU rendering<br>
            ⚠️ <strong>Cons:</strong> Requires WebGL knowledge, more complex code
        </p>
    </div>

    <script type="module">
        import { GameOfLifeSimulation } from '../game-of-life/game-of-life-sim.js';

        const SIZE = 512;
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');

        // Create custom rendering pipeline
        const renderProgram = createRenderProgram(gl);
        const quadBuffer = createQuadBuffer(gl);

        // Create simulation (async)
        let sim;
        GameOfLifeSimulation.create(SIZE, SIZE, { initialState: 'random' }).then(instance => {
            sim = instance;
            render();
            requestAnimationFrame(animate);
        });

        function createRenderProgram(gl) {
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, `
                attribute vec2 a_position;
                varying vec2 v_texCoord;
                void main() {
                    v_texCoord = (a_position + 1.0) * 0.5;
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            `);
            gl.compileShader(vertexShader);

            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, `
                precision highp float;
                uniform sampler2D u_texture;
                varying vec2 v_texCoord;
                
                void main() {
                    float value = texture2D(u_texture, v_texCoord).r;
                    
                    // Heat map effect
                    vec3 color;
                    if (value > 0.5) {
                        // Alive cells: gradient from yellow to red
                        color = vec3(1.0, 1.0 - value, 0.0);
                    } else {
                        // Dead cells: dark blue
                        color = vec3(0.0, 0.0, value * 0.3);
                    }
                    
                    gl_FragColor = vec4(color, 1.0);
                }
            `);
            gl.compileShader(fragmentShader);

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            return program;
        }

        function createQuadBuffer(gl) {
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1,
                1, -1,
                -1, 1,
                1, 1
            ]), gl.STATIC_DRAW);
            return buffer;
        }

        function render() {
            if (!sim) return;
            // Get simulation texture (no CPU download!)
            const texture = sim.getTexture();
            
            // Render with custom shader
            gl.useProgram(renderProgram);
            
            const positionLocation = gl.getAttribLocation(renderProgram, 'a_position');
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            
            const textureLocation = gl.getUniformLocation(renderProgram, 'u_texture');
            gl.uniform1i(textureLocation, 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        function animate() {
            if (!sim) {
                requestAnimationFrame(animate);
                return;
            }
            sim.step();
            render();
            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>

