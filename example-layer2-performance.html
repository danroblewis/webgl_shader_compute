<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Layer 2 Example: Performance-Critical (Buffer Access)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
        }
        .layer-badge {
            display: inline-block;
            background: #FF9800;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        canvas {
            border: 1px solid #ddd;
            display: block;
            margin: 20px auto;
        }
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #FF9800;
            color: white;
            transition: background 0.2s;
        }
        button:hover {
            background: #F57C00;
        }
        .stats {
            background: #fff8e1;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
            border-left: 4px solid #FF9800;
        }
        .stats-row {
            display: grid;
            grid-template-columns: 200px 1fr;
            gap: 10px;
            margin: 8px 0;
        }
        .stats-label {
            font-weight: bold;
            color: #666;
        }
        .stats-value {
            color: #333;
            font-family: 'Consolas', monospace;
        }
        .performance-highlight {
            color: #FF6F00;
            font-weight: bold;
        }
        .code-section {
            background: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 20px 0;
        }
        .code-section pre {
            margin: 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.5;
        }
        .highlight {
            color: #e5c07b;
        }
        .comment {
            color: #5c6370;
            font-style: italic;
        }
    </style>
</head>
<body>
    <h1>High-Performance Simulation <span class="layer-badge">LAYER 2: Buffer Access</span></h1>
    
    <div class="container">
        <p>
            This example demonstrates <strong>performance-critical patterns</strong> using Layer 2 (Direct Buffer Access).
            We run <strong>1000 generations instantly</strong>, then analyze the results efficiently.
        </p>
        <p class="performance-highlight">
            ‚ö° Key optimization: Download buffer ONCE, then perform all queries on cached data.
        </p>
    </div>

    <canvas id="canvas" width="1024" height="1024"></canvas>

    <div class="container">
        <div class="controls">
            <button id="run1000Btn">Run 1000 Generations</button>
            <button id="run10000Btn">Run 10,000 Generations</button>
            <button id="analyzeBtn">Deep Analysis</button>
            <button id="resetBtn">Reset</button>
        </div>

        <div class="stats">
            <div class="stats-row">
                <div class="stats-label">Generation:</div>
                <div class="stats-value" id="generation">0</div>
            </div>
            <div class="stats-row">
                <div class="stats-label">Last Batch Time:</div>
                <div class="stats-value" id="batchTime">-</div>
            </div>
            <div class="stats-row">
                <div class="stats-label">Iterations/Second:</div>
                <div class="stats-value performance-highlight" id="ips">-</div>
            </div>
            <div class="stats-row">
                <div class="stats-label">Buffer Downloads:</div>
                <div class="stats-value" id="downloads">0</div>
            </div>
            <div class="stats-row">
                <div class="stats-label">Alive Cells:</div>
                <div class="stats-value" id="alive">-</div>
            </div>
            <div class="stats-row">
                <div class="stats-label">Density:</div>
                <div class="stats-value" id="density">-</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Layer 2 API: Direct Buffer Access</h2>
        <div class="code-section">
            <pre><span class="comment">// PERFORMANCE PATTERN: Download once, query many times</span>

<span class="comment">// Run 1000 steps: ZERO downloads (pure GPU)</span>
for (let i = 0; i < 1000; i++) {
    sim.<span class="highlight">step</span>();  <span class="comment">// No GPU‚ÜíCPU transfer!</span>
}

<span class="comment">// Download buffer ONCE</span>
const buffer = sim.<span class="highlight">getCurrentBuffer</span>();  <span class="comment">// Float32Array reference</span>

<span class="comment">// Perform many queries on cached buffer (FAST!)</span>
let alive = 0;
for (let i = 0; i < buffer.length; i++) {
    if (buffer[i] > 0.5) alive++;
}

<span class="comment">// Modify buffer directly, then sync back</span>
buffer[512] = 1.0;
buffer[513] = 1.0;
sim.<span class="highlight">syncBuffer</span>(buffer);  <span class="comment">// Upload changes to GPU</span>

<span class="comment">// Check if buffer is stale</span>
if (sim.<span class="highlight">isBufferStale</span>()) {
    console.log('Need to re-download');
}
</pre>
        </div>
        <p>
            ‚úÖ <strong>Pros:</strong> Maximum performance, bulk operations efficient<br>
            ‚ö†Ô∏è <strong>Note:</strong> Must manually manage download timing
        </p>
    </div>

    <script type="module">
        import { GridSimulation } from './grid-simulation.js';

        const SIZE = 256;
        const CELL_SIZE = 4;
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Create simulation
        const sim = new GridSimulation({
            width: SIZE,
            height: SIZE,
            rule: 'gameOfLife',
            initialState: 'random'
        });

        let downloadCount = 0;

        // Efficient render using buffer reference
        function render() {
            const buffer = sim.getCurrentBuffer();
            downloadCount++;
            
            const imageData = ctx.createImageData(SIZE, SIZE);
            for (let i = 0; i < buffer.length; i++) {
                const alive = buffer[i] > 0.5;
                const baseIdx = i * 4;
                imageData.data[baseIdx] = alive ? 255 : 0;
                imageData.data[baseIdx + 1] = alive ? 255 : 0;
                imageData.data[baseIdx + 2] = alive ? 255 : 0;
                imageData.data[baseIdx + 3] = 255;
            }
            
            ctx.putImageData(imageData, 0, 0);
            ctx.drawImage(canvas, 0, 0, SIZE, SIZE, 0, 0, canvas.width, canvas.height);
            
            updateStats(buffer);
        }

        function updateStats(buffer = null) {
            document.getElementById('generation').textContent = sim.generation.toLocaleString();
            document.getElementById('downloads').textContent = downloadCount;
            
            if (buffer) {
                let alive = 0;
                for (let i = 0; i < buffer.length; i++) {
                    if (buffer[i] > 0.5) alive++;
                }
                const density = ((alive / buffer.length) * 100).toFixed(2);
                document.getElementById('alive').textContent = alive.toLocaleString();
                document.getElementById('density').textContent = density + '%';
            }
        }

        // Run N generations and measure performance
        function runBatch(count) {
            const startTime = performance.now();
            
            // Pure GPU computation - ZERO downloads!
            sim.step(count);
            
            const elapsed = performance.now() - startTime;
            const ips = Math.floor(count / (elapsed / 1000));
            
            // Now download ONCE for visualization
            render();
            
            // Update performance stats
            document.getElementById('batchTime').textContent = 
                `${elapsed.toFixed(2)}ms (${count.toLocaleString()} generations)`;
            document.getElementById('ips').textContent = ips.toLocaleString();
            
            console.log(`‚ö° ${count} generations in ${elapsed.toFixed(2)}ms (~${ips} iterations/sec)`);
        }

        // Deep analysis: Download once, perform many queries
        function deepAnalysis() {
            console.log('üîç Starting deep analysis...');
            const analysisStart = performance.now();
            
            // Download buffer ONCE
            const buffer = sim.getCurrentBuffer();
            downloadCount++;
            
            // Perform complex analysis on cached buffer
            let alive = 0;
            let isolated = 0;  // Cells with no neighbors
            let crowded = 0;   // Cells with 5+ neighbors
            
            for (let y = 0; y < SIZE; y++) {
                for (let x = 0; x < SIZE; x++) {
                    const idx = y * SIZE + x;
                    const cell = buffer[idx];
                    
                    if (cell > 0.5) {
                        alive++;
                        
                        // Count neighbors
                        let neighbors = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nx = (x + dx + SIZE) % SIZE;
                                const ny = (y + dy + SIZE) % SIZE;
                                const nidx = ny * SIZE + nx;
                                if (buffer[nidx] > 0.5) neighbors++;
                            }
                        }
                        
                        if (neighbors === 0) isolated++;
                        if (neighbors >= 5) crowded++;
                    }
                }
            }
            
            const analysisTime = performance.now() - analysisStart;
            
            // Display results
            alert(`Analysis Complete (${analysisTime.toFixed(2)}ms):
            
Alive Cells: ${alive.toLocaleString()}
Isolated Cells: ${isolated.toLocaleString()}
Crowded Cells (5+ neighbors): ${crowded.toLocaleString()}
Density: ${((alive / (SIZE * SIZE)) * 100).toFixed(2)}%

Total Downloads: ${downloadCount} (only 1 for this analysis!)
            `);
            
            console.log(`‚úÖ Deep analysis complete in ${analysisTime.toFixed(2)}ms`);
        }

        // Controls
        document.getElementById('run1000Btn').addEventListener('click', () => {
            runBatch(1000);
        });

        document.getElementById('run10000Btn').addEventListener('click', () => {
            runBatch(10000);
        });

        document.getElementById('analyzeBtn').addEventListener('click', () => {
            deepAnalysis();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            sim.randomize(0.3);
            sim.generation = 0;
            downloadCount = 0;
            render();
            document.getElementById('batchTime').textContent = '-';
            document.getElementById('ips').textContent = '-';
        });

        // Initial render
        render();
    </script>
</body>
</html>

