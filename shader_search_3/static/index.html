<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shader Search 3</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css"
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <link rel="stylesheet" href="/static/app.css" />
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@18.2.0",
          "react-dom": "https://esm.sh/react-dom@18.2.0",
          "react-dom/client": "https://esm.sh/react-dom@18.2.0/client"
        }
      }
    </script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
  </head>
  <body>
    <header>
      <h1>Shader Search 3</h1>
      <p>Manage evolution configurations and cellular automata test suites.</p>
    </header>
    <main id="root">
      <noscript>You need JavaScript to run this application.</noscript>
    </main>
    <footer>
      Served by FastAPI • React via CDN • No build tooling required
    </footer>

    <script type="module">
      // Recursive JSX loader - transforms JSX and handles nested imports
      const moduleCache = new Map()
      
      async function loadJSX(url, baseUrl = window.location.href) {
        const fullUrl = new URL(url, baseUrl).href
        if (moduleCache.has(fullUrl)) {
          return moduleCache.get(fullUrl)
        }
        
        const response = await fetch(fullUrl)
        let code = await response.text()
        
        // Find all import statements
        const importRegex = /import\s+([^'"]+)\s+from\s+['"]([^'"]+)['"]/g
        const imports = []
        let match
        while ((match = importRegex.exec(code)) !== null) {
          imports.push({ spec: match[1], from: match[2], full: match[0] })
        }
        
        // Load all imports first (recursively for JSX files, via importmap for React)
        const importMap = {}
        for (const { spec, from } of imports) {
          let resolvedUrl = from
          if (from.startsWith('./') || from.startsWith('../')) {
            resolvedUrl = new URL(from, fullUrl).href
          }
          
          let module
          if (resolvedUrl.endsWith('.jsx') || (resolvedUrl.endsWith('.js') && (from.startsWith('./') || from.startsWith('../')))) {
            // Load JSX or local JS file recursively
            module = await loadJSX(resolvedUrl, fullUrl)
          } else {
            // Load non-local imports (React, etc.) via importmap
            const importMapEntry = document.querySelector('script[type="importmap"]')
            let mapped = from
            if (importMapEntry) {
              const importMapData = JSON.parse(importMapEntry.textContent)
              mapped = importMapData.imports?.[from] || from
            }
            module = await import(mapped)
          }
          
          // Store module in importMap by import spec
          if (spec.startsWith('{')) {
            // Named imports: { useState, useEffect } -> importMap['useState'], etc.
            const names = spec.slice(1, -1).split(',').map(s => s.trim())
            names.forEach(name => {
              const cleanName = name.split(' as ')[0].trim()
              const alias = name.split(' as ')[1]?.trim()
              const key = alias || cleanName
              // For named exports, get from module directly (module is the exports object for JSX files)
              importMap[key] = module[cleanName] || (module.default && typeof module.default === 'object' ? module.default[cleanName] : undefined)
              if (!importMap[key]) {
                console.warn(`Could not find export '${cleanName}' in module`, module)
              }
            })
          } else if (spec.startsWith('*')) {
            // Namespace import: * as React
            const alias = spec.split(' as ')[1]?.trim() || 'default'
            importMap[alias] = module
          } else {
            // Default import: React
            const varName = spec.trim()
            importMap[varName] = module.default || module
          }
        }
        
        // Handle export statements BEFORE replacing imports and transforming
        // Find all exported consts, functions, and classes to add to exports later
        const exportedConsts = []
        const exportedFunctions = []
        const exportedClasses = []
        let defaultExportName = null
        
        // Extract default export name BEFORE transformation (but handle export statement AFTER)
        const defaultExportMatch = code.match(/export\s+default\s+(?:function|const|class)\s+(\w+)/)
        if (defaultExportMatch) {
          defaultExportName = defaultExportMatch[1]
        }
        
        // Remove export default but keep the declaration - we'll handle it after JSX transform
        code = code.replace(/export\s+default\s+/g, '')
        
        code = code.replace(/export\s+const\s+(\w+)\s*=/g, (match, name) => {
          exportedConsts.push(name)
          return `const ${name} =`
        })
        code = code.replace(/export\s+function\s+(\w+)/g, (match, name) => {
          exportedFunctions.push(name)
          return `function ${name}`
        })
        code = code.replace(/export\s+class\s+(\w+)/g, (match, name) => {
          exportedClasses.push(name)
          return `class ${name}`
        })
        
        // Replace all imports with loaded modules from importMap
        imports.forEach(({ spec, from, full }) => {
          if (spec.startsWith('{')) {
            // Named imports: { useState, useEffect } -> const useState = importMap['useState']; const useEffect = importMap['useEffect'];
            const names = spec.slice(1, -1).split(',').map(s => s.trim())
            const declarations = names.map(name => {
              const cleanName = name.split(' as ')[0].trim()
              const alias = name.split(' as ')[1]?.trim() || cleanName
              return `const ${alias} = importMap['${alias}']`
            }).join('; ')
            code = code.replace(full, declarations)
          } else if (spec.startsWith('*')) {
            // Namespace import: * as React -> const React = importMap['React']
            const alias = spec.split(' as ')[1]?.trim() || 'default'
            code = code.replace(full, `const ${alias} = importMap['${alias}']`)
          } else {
            // Default import: React -> const React = importMap['React']
            const varName = spec.trim()
            code = code.replace(full, `const ${varName} = importMap['${varName}']`)
          }
        })
        
        // Transform JSX only for .jsx files
        const isJSX = fullUrl.endsWith('.jsx')
        if (isJSX) {
          code = Babel.transform(code, {
            presets: ['react'],
          }).code
        }
        
        code = code.replace(/export\s+const\s+\{([^}]+)\}\s*=/g, 'const {$1} =')
        // For export default <identifier> (already declared variable/function) - handle AFTER JSX transform
        code = code.replace(/export\s+default\s+(\w+)(?!\s*\()/g, (match, name) => {
          return `${name}; exports.default = ${name}`
        })
        // For any remaining export default (shouldn't happen, but fallback)
        code = code.replace(/export\s+default\s+/g, 'const __defaultExport = ')
        
        // Add exports for exported consts, functions, and classes at the end of the code
        const allExports = [...exportedConsts, ...exportedFunctions, ...exportedClasses]
        const exportStatements = []
        if (allExports.length > 0) {
          exportStatements.push(...allExports.map(name => `exports.${name} = ${name}`))
        }
        // Handle default exports
        if (defaultExportName) {
          exportStatements.push(`exports.default = ${defaultExportName}`)
        }
        // For named exports, replace with export statements but keep original code
        const namedExports = []
        code = code.replace(/export\s+\{([^}]+)\}/g, (match, names) => {
          const exportStatements = names.split(',').map(n => {
            const trimmed = n.trim()
            const [name, alias] = trimmed.split(' as ')
            const exportName = alias || name
            return `exports.${exportName} = ${name}`
          }).join('; ')
          namedExports.push(exportStatements)
          return '' // Remove the export statement, we'll add exports at the end
        })
        // Add all export statements at once at the end
        const allExportStatements = [...exportStatements]
        if (namedExports.length > 0) {
          allExportStatements.push(...namedExports)
        }
        if (allExportStatements.length > 0) {
          const trimmedCode = code.trim()
          // Add exports at the end - need semicolon if code ends with } or )
          const lastChar = trimmedCode[trimmedCode.length - 1]
          let separator = ' '
          if (lastChar === '}' || lastChar === ')') {
            separator = '; '
          } else if (lastChar !== ';') {
            separator = '; '
          }
          code = trimmedCode + separator + allExportStatements.join('; ')
        }
        
        // Execute module - make React available for JSX transformation (only for .jsx files)
        const exports = {}
        const moduleObj = { exports }
        
        // Debug: log code before execution
        console.log(`[${fullUrl}] Code length: ${code.length}, isJSX: ${isJSX}`)
        console.log(`[${fullUrl}] Code ends with:`, code.substring(Math.max(0, code.length - 100)))
        
        if (isJSX) {
          // Check if React is already declared in the code
          const hasReactDeclared = /const\s+React\s*=/.test(code) || /let\s+React\s*=/.test(code) || /var\s+React\s*=/.test(code)
          
          // Extract React from importMap - check all possible keys
          let React = importMap['React'] || importMap['react']
          // If React wasn't imported directly, try to get it from the importmap
          if (!React && !hasReactDeclared) {
            const importMapEntry = document.querySelector('script[type="importmap"]')
            if (importMapEntry) {
              const importMapData = JSON.parse(importMapEntry.textContent)
              const reactUrl = importMapData.imports?.['react']
              if (reactUrl) {
                // Import React on the fly if needed
                const reactModule = await import(reactUrl)
                React = reactModule.default || reactModule
              }
            }
          }
          // If still no React and not declared, create a dummy (shouldn't happen)
          if (!hasReactDeclared) {
            React = React || { createElement: () => {} }
            try {
              console.log(`Creating Function for ${fullUrl} (with React param)`)
              const func = new Function('importMap', 'React', 'module', 'exports', code)
              func(importMap, React, moduleObj, exports)
            } catch (err) {
              console.error(`Error executing ${fullUrl}:`, err)
              console.error('Code length:', code.length)
              console.error('Code snippet (first 1000 chars):', code.substring(0, 1000))
              console.error('Code snippet (last 500 chars):', code.substring(Math.max(0, code.length - 500)))
              throw err
            }
          } else {
            // React is already declared in code, don't pass it as parameter
            try {
              console.log(`Creating Function for ${fullUrl} (React already declared)`)
              const func = new Function('importMap', 'module', 'exports', code)
              func(importMap, moduleObj, exports)
            } catch (err) {
              console.error(`Error executing ${fullUrl}:`, err)
              console.error('Code length:', code.length)
              console.error('Code snippet (first 1000 chars):', code.substring(0, 1000))
              console.error('Code snippet (last 500 chars):', code.substring(Math.max(0, code.length - 500)))
              throw err
            }
          }
        } else {
          // For .js files, no React needed
          try {
            console.log(`Creating Function for ${fullUrl} (.js file)`)
            const func = new Function('importMap', 'module', 'exports', code)
            func(importMap, moduleObj, exports)
          } catch (err) {
            console.error(`Error executing ${fullUrl}:`, err)
            console.error('Code length:', code.length)
            console.error('Code snippet (first 1000 chars):', code.substring(0, 1000))
            console.error('Code snippet (last 500 chars):', code.substring(Math.max(0, code.length - 500)))
            throw err
          }
        }
        
        moduleCache.set(fullUrl, exports)
        return exports
      }
      
      // Load app
      await loadJSX('/static/app.jsx')
    </script>
  </body>
</html>
